From d209582c297d376da27f80dc62c59b2f5440da25 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Wed, 1 Apr 2015 04:34:20 +0200
Subject: ntdll: Load CLI/.NET images in the same way as Windows XP and above.

---
 dlls/ntdll/loader.c | 127 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 123 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index cdf8d586c36..fa66c4c40d2 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -104,11 +104,16 @@ struct builtin_load_info
 static struct builtin_load_info default_load_info;
 static struct builtin_load_info *builtin_load_info = &default_load_info;
 
+static CONTEXT start_context = { 0 };
 static HANDLE main_exe_file;
 static UINT tls_module_count;      /* number of modules with TLS directory */
 static IMAGE_TLS_DIRECTORY *tls_dirs;  /* array of TLS directories */
 LIST_ENTRY tls_links = { &tls_links, &tls_links };
 
+static HRESULT (WINAPI *p_CorValidateImage)(PVOID* ImageBase, LPCWSTR FileName);
+static __int32 (WINAPI *p_CorExeMain)(void);
+static BOOL    (WINAPI *p_CorDllMain)(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);
+
 static RTL_CRITICAL_SECTION loader_section;
 static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
 {
@@ -341,6 +346,78 @@ static inline ULONG_PTR allocate_stub( c
 
 
 /*************************************************************************
+ *      is_cli_only_image
+ *
+ * Checks if an image is a CLI/.NET image which does not contain any
+ * native code.
+ */
+static BOOL is_cli_only_image( HMODULE image )
+{
+    IMAGE_COR20_HEADER *cliheader;
+    ULONG size;
+
+    cliheader = RtlImageDirectoryEntryToData( image, TRUE, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR, &size );
+    if (!cliheader || size < sizeof(*cliheader))
+        return FALSE;
+
+    return (cliheader->Flags & COMIMAGE_FLAGS_ILONLY) != 0;
+}
+
+
+/*************************************************************************
+ *      load_mscoree
+ *
+ * Load _CorValidateImage and the _Cor{Exe,Dll}Main functions from mscoree.
+ * The loader_section must be locked while calling this function.
+ */
+static BOOL load_mscoree( void )
+{
+    static const WCHAR mscoree_dllW[] = {'m','s','c','o','r','e','e','.','d','l','l',0};
+    UNICODE_STRING unicode_str;
+    ANSI_STRING ansi_str;
+    HMODULE module;
+
+    if (p_CorValidateImage)
+        return TRUE;
+
+    RtlInitUnicodeString( &unicode_str, mscoree_dllW );
+    if (LdrLoadDll( NULL, LOAD_LIBRARY_SEARCH_SYSTEM32, &unicode_str, &module ))
+    {
+        ERR( "Failed to load mscoree.dll\n" );
+        return FALSE;
+    }
+
+    /* Load _CorValidateImage */
+    RtlInitAnsiString( &ansi_str, "_CorValidateImage" );
+    if (LdrGetProcedureAddress( module, &ansi_str, 0, (void **)&p_CorValidateImage) )
+    {
+        ERR( "Failed to get import for _CorValidateImage\n" );
+        LdrUnloadDll( module );
+        return FALSE;
+    }
+
+    /* Load _CorExeMain */
+    RtlInitAnsiString( &ansi_str, "_CorExeMain" );
+    if (LdrGetProcedureAddress( module, &ansi_str, 0, (void **)&p_CorExeMain) )
+    {
+        ERR( "Failed to get import for _CorExeMain\n" );
+        p_CorExeMain = NULL;
+    }
+
+    /* Load _CorDllMain */
+    RtlInitAnsiString( &ansi_str, "_CorDllMain" );
+    if (LdrGetProcedureAddress( module, &ansi_str, 0, (void **)&p_CorDllMain) )
+    {
+        ERR( "Failed to get import for _CorDllMain\n" );
+        p_CorDllMain = NULL;
+    }
+
+    /* FIXME: Unload mscoree again when no longer needed */
+    return TRUE;
+}
+
+
+/*************************************************************************
  *		get_modref
  *
  * Looks for the referenced HMODULE in the current process
@@ -917,6 +994,10 @@ static NTSTATUS fixup_imports( WINE_MODR
     if (!(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS)) return STATUS_SUCCESS;  /* already done */
     wm->ldr.Flags &= ~LDR_DONT_RESOLVE_REFS;
 
+    /* For a CLI-only image there is nothing to do. Do not allocate a TLS slot
+     * and do not resolve any external dependencies. */
+    if (is_cli_only_image( wm->ldr.BaseAddress )) return STATUS_SUCCESS;
+
     wm->ldr.TlsIndex = alloc_tls_slot( &wm->ldr );
 
     if (!(imports = RtlImageDirectoryEntryToData( wm->ldr.BaseAddress, TRUE,
@@ -1107,8 +1188,47 @@ static NTSTATUS MODULE_InitDLL( WINE_MOD
     BOOL retv = FALSE;
 
     /* Skip calls for modules loaded with special load flags */
-
     if (wm->ldr.Flags & LDR_DONT_RESOLVE_REFS) return STATUS_SUCCESS;
+
+    /* Yes, Windows also has hardcoded exceptions for mscoree in ntdll */
+    if (is_cli_only_image( module ))
+    {
+    #ifndef __x86_64__
+        IMAGE_NT_HEADERS *nt = RtlImageNtHeader( module );
+    #endif
+
+        if (reason == DLL_WINE_PREATTACH)
+            return STATUS_SUCCESS;
+
+        if (reason == DLL_PROCESS_ATTACH)
+        {
+            HRESULT hr;
+
+            if (!load_mscoree())
+                return STATUS_DLL_INIT_FAILED;
+
+            hr = p_CorValidateImage( &module, wm->ldr.FullDllName.Buffer );
+            if (hr)
+            {
+                ERR( "failed to validate CLI image, error 0x%x\n", hr );
+                wm->ldr.EntryPoint = NULL;
+                return STATUS_DLL_INIT_FAILED;
+            }
+
+        #ifdef __x86_64__
+            wm->ldr.EntryPoint = (wm->ldr.Flags & LDR_IMAGE_IS_DLL) ?
+                                 (void *)p_CorDllMain : (void *)p_CorExeMain;
+        #else
+            wm->ldr.EntryPoint = (char *)module + nt->OptionalHeader.AddressOfEntryPoint;
+        #endif
+
+            if (!(wm->ldr.Flags & LDR_IMAGE_IS_DLL))
+                start_context.ContextFlags = 0;
+
+            entry = wm->ldr.EntryPoint;
+        }
+    }
+
     if (wm->ldr.TlsIndex != -1) call_tls_callbacks( wm->ldr.BaseAddress, reason );
     if (!entry || !(wm->ldr.Flags & LDR_IMAGE_IS_DLL)) return STATUS_SUCCESS;
 
@@ -3329,12 +3449,17 @@ void WINAPI LdrInitializeThunk( void *ke
              debugstr_w(peb->ProcessParameters->ImagePathName.Buffer), status );
         NtTerminateProcess( GetCurrentProcess(), status );
     }
+    if ((status = server_init_process_done( &start_context )) != STATUS_SUCCESS)
+    {
+        ERR( "Main exe initialization for %s failed, status %x\n",
+             debugstr_w(peb->ProcessParameters->ImagePathName.Buffer), status );
+        NtTerminateProcess( GetCurrentProcess(), status );
+    }
 
     timeout.QuadPart = 0;
     NtDelayExecution( TRUE, &timeout );
 
-    server_init_process_done();
+	server_init_process_done();
 }
 
 
-- 
2.14.1
