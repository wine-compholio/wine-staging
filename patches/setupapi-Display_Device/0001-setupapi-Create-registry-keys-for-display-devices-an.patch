From 9fb320afdf57221eb32d51a03971ad3d13cf773e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Thu, 11 Feb 2016 03:17:09 +0100
Subject: setupapi: Create registry keys for display devices and display
 drivers.

---
 dlls/setupapi/devinst.c | 111 ++++++++++++++++++++++++++++++++++++++++++------
 loader/wine.inf.in      |   2 +
 2 files changed, 101 insertions(+), 12 deletions(-)

diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index 4d53bd7..6415298 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -94,6 +94,15 @@ static const WCHAR SymbolicLink[] = {'S','y','m','b','o','l','i','c','L','i','n'
 static const WCHAR Control[] = {'C','o','n','t','r','o','l',0};
 static const WCHAR Linked[] = {'L','i','n','k','e','d',0};
 
+/* GUIDs */
+static const WCHAR displayGUIDW[] = {'{','4','d','3','6','e','9','6','8','-','e','3','2','5','-',
+                                     '1','1','c','e','-','b','f','c','1','-',
+                                     '0','8','0','0','2','b','e','1','0','3','1','8','}',0};
+static const WCHAR ddriverGUIDW[] = {'{','4','d','3','6','e','9','6','8','-','e','3','2','5','-',
+                                     '1','1','c','e','-','b','f','c','1','-',
+                                     '0','8','0','0','2','b','e','1','0','3','1','8','}',
+                                     '\\','0','0','0','0',0};
+
 /* is used to identify if a DeviceInfoSet pointer is
 valid or not */
 #define SETUP_DEVICE_INFO_SET_MAGIC 0xd00ff056
@@ -129,6 +138,90 @@ struct device_iface
     struct list      entry;
 };
 
+static void create_display_keys(HKEY enumKey, int index, DISPLAY_DEVICEW *disp)
+{
+    static const WCHAR fmtW[] = {'1','3','&','1','2','3','4','5','&','%','d',0};
+    HKEY devKey, intKey;
+    WCHAR buffer[50];
+    LONG l;
+
+    l = RegCreateKeyExW(enumKey, disp->DeviceID, 0, NULL, 0, KEY_ALL_ACCESS,
+                        NULL, &devKey, NULL);
+    if (l) return;
+
+    snprintfW(buffer, sizeof(buffer) / sizeof(WCHAR), fmtW, index);
+    l = RegCreateKeyExW(devKey, buffer, 0, NULL, 0, KEY_ALL_ACCESS,
+                        NULL, &intKey, NULL);
+    if (!l)
+    {
+        RegSetValueExW(intKey, ClassGUID, 0, REG_SZ, (BYTE *)displayGUIDW, sizeof(displayGUIDW));
+        RegSetValueExW(intKey, Driver, 0, REG_SZ, (BYTE *)ddriverGUIDW, sizeof(ddriverGUIDW));
+        RegCloseKey(intKey);
+    }
+
+    RegCloseKey(devKey);
+}
+
+static void create_display_driver_keys(void)
+{
+    static const WCHAR DriverDateDataW[] = {'D','r','i','v','e','r','D','a','t','e','D','a','t','a',0};
+    HKEY classesKey, driverKey;
+    SYSTEMTIME systime;
+    FILETIME filetime;
+    LONG l;
+
+    l = RegCreateKeyExW(HKEY_LOCAL_MACHINE, ControlClass, 0, NULL, 0, KEY_ALL_ACCESS,
+                        NULL, &classesKey, NULL);
+    if (l) return;
+
+    l = RegCreateKeyExW(classesKey, ddriverGUIDW, 0, NULL, 0, KEY_ALL_ACCESS,
+                        NULL, &driverKey, NULL);
+    if (!l)
+    {
+        /* we are really keeping our drivers up to date */
+        GetSystemTime(&systime);
+        if (SystemTimeToFileTime(&systime, &filetime))
+            RegSetValueExW(driverKey, DriverDateDataW, 0, REG_BINARY, (BYTE *)&filetime, sizeof(filetime));
+
+        RegCloseKey(driverKey);
+    }
+
+    RegCloseKey(classesKey);
+}
+
+static LONG open_enum_key(HKEY *key)
+{
+    static BOOL initialized = FALSE;
+    DISPLAY_DEVICEW disp;
+    HKEY enumKey;
+    LONG l;
+
+    l = RegCreateKeyExW(HKEY_LOCAL_MACHINE, Enum, 0, NULL, 0, KEY_ALL_ACCESS,
+                        NULL, &enumKey, NULL);
+    if (l) return l;
+
+    if (!initialized)
+    {
+        /* Wine currently does not properly distinguish between monitors and
+         * display devices yet. On a multi monitor system the enumeration
+         * returns multiple devices although there is only one graphic card.
+         * To work around this, we stop the enumeration after the first device. */
+
+        TRACE("creating display keys\n");
+
+        disp.cb = sizeof(disp);
+        if (EnumDisplayDevicesW(NULL, 0, &disp, 0))
+            create_display_keys(enumKey, 0, &disp);
+
+        create_display_driver_keys();
+
+        initialized = TRUE;
+    }
+
+    *key = enumKey;
+    return ERROR_SUCCESS;
+}
+
 static inline void copy_device_data(SP_DEVINFO_DATA *data, const struct device *device)
 {
     data->ClassGuid = device->class;
@@ -418,8 +511,7 @@ static HKEY SETUPDI_CreateDevKey(struct device *device)
     HKEY enumKey, key = INVALID_HANDLE_VALUE;
     LONG l;
 
-    l = RegCreateKeyExW(HKEY_LOCAL_MACHINE, Enum, 0, NULL, 0, KEY_ALL_ACCESS,
-            NULL, &enumKey, NULL);
+    l = open_enum_key(&enumKey);
     if (!l)
     {
         RegCreateKeyExW(enumKey, device->instanceId, 0, NULL, 0,
@@ -511,8 +603,7 @@ static void SETUPDI_RemoveDevice(struct device *device)
         HKEY enumKey;
         LONG l;
 
-        l = RegCreateKeyExW(HKEY_LOCAL_MACHINE, Enum, 0, NULL, 0,
-                KEY_ALL_ACCESS, NULL, &enumKey, NULL);
+        l = open_enum_key(&enumKey);
         if (!l)
         {
             RegDeleteTreeW(enumKey, device->instanceId);
@@ -2042,8 +2133,7 @@ static void SETUPDI_EnumerateMatchingInterfaces(HDEVINFO DeviceInfoSet,
 
     TRACE("%s\n", debugstr_w(enumstr));
 
-    l = RegCreateKeyExW(HKEY_LOCAL_MACHINE, Enum, 0, NULL, 0, KEY_READ, NULL,
-            &enumKey, NULL);
+    l = open_enum_key(&enumKey);
     for (i = 0; !l; i++)
     {
         len = sizeof(subKeyName) / sizeof(subKeyName[0]);
@@ -2269,8 +2359,7 @@ static void SETUPDI_EnumerateDevices(HDEVINFO DeviceInfoSet, const GUID *class,
     TRACE("%p, %s, %s, %08x\n", DeviceInfoSet, debugstr_guid(class),
             debugstr_w(enumstr), flags);
 
-    l = RegCreateKeyExW(HKEY_LOCAL_MACHINE, Enum, 0, NULL, 0, KEY_READ, NULL,
-            &enumKey, NULL);
+    l = open_enum_key(&enumKey);
     if (enumKey != INVALID_HANDLE_VALUE)
     {
         if (enumstr)
@@ -3609,8 +3698,7 @@ static HKEY SETUPDI_OpenDevKey(struct device *device, REGSAM samDesired)
     HKEY enumKey, key = INVALID_HANDLE_VALUE;
     LONG l;
 
-    l = RegCreateKeyExW(HKEY_LOCAL_MACHINE, Enum, 0, NULL, 0, KEY_ALL_ACCESS,
-            NULL, &enumKey, NULL);
+    l = open_enum_key(&enumKey);
     if (!l)
     {
         RegOpenKeyExW(enumKey, device->instanceId, 0, samDesired, &key);
@@ -3726,8 +3814,7 @@ static BOOL SETUPDI_DeleteDevKey(struct device *device)
     BOOL ret = FALSE;
     LONG l;
 
-    l = RegCreateKeyExW(HKEY_LOCAL_MACHINE, Enum, 0, NULL, 0, KEY_ALL_ACCESS,
-            NULL, &enumKey, NULL);
+    l = open_enum_key(&enumKey);
     if (!l)
     {
         ret = RegDeleteTreeW(enumKey, device->instanceId);
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 79ac6c5..2a2313e 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -465,6 +465,8 @@ HKLM,System\CurrentControlSet\Control\ContentIndex\Language\Neutral,"Locale",0x1
 [ControlClass]
 HKLM,System\CurrentControlSet\Control\Class\{4d36e967-e325-11ce-bfc1-08002be10318},,,"Disk drives"
 HKLM,System\CurrentControlSet\Control\Class\{4d36e967-e325-11ce-bfc1-08002be10318},"Class",,"DiskDrive"
+HKLM,System\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318},,,"Display drivers"
+HKLM,System\CurrentControlSet\Control\Class\{4d36e968-e325-11ce-bfc1-08002be10318},"Class",,"Display"
 HKLM,System\CurrentControlSet\Control\Class\{4d36e978-e325-11ce-bfc1-08002be10318},,,"Ports (COM & LPT)"
 HKLM,System\CurrentControlSet\Control\Class\{4d36e978-e325-11ce-bfc1-08002be10318},"Class",,"Ports"
 HKLM,System\CurrentControlSet\Control\Class\{6bdd1fc6-810f-11d0-bec7-08002be2092f},,,"Imaging devices"
-- 
2.7.4

