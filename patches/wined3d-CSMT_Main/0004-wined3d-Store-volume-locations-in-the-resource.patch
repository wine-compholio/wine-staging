From d9832814763ffc0c5b9f43223507f049a60859f5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Stefan=20D=C3=B6singer?= <stefan@codeweavers.com>
Date: Thu, 3 Oct 2013 12:31:24 +0200
Subject: wined3d: Store volume locations in the resource.

---
 dlls/wined3d/volume.c          | 46 +++++++++++++++++++++---------------------
 dlls/wined3d/wined3d_private.h |  4 ++--
 2 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
index c4bd3e7..d9405b9 100644
--- a/dlls/wined3d/volume.c
+++ b/dlls/wined3d/volume.c
@@ -102,15 +102,15 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
 void wined3d_volume_validate_location(struct wined3d_volume *volume, DWORD location)
 {
     TRACE("Volume %p, setting %s.\n", volume, wined3d_debug_location(location));
-    volume->locations |= location;
-    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
+    volume->resource.locations |= location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->resource.locations));
 }
 
 void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location)
 {
     TRACE("Volume %p, clearing %s.\n", volume, wined3d_debug_location(location));
-    volume->locations &= ~location;
-    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
+    volume->resource.locations &= ~location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->resource.locations));
 }
 
 /* Context activation is done by the caller. */
@@ -216,9 +216,9 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
     DWORD required_access = volume_access_from_location(location);
 
     TRACE("Volume %p, loading %s, have %s.\n", volume, wined3d_debug_location(location),
-        wined3d_debug_location(volume->locations));
+        wined3d_debug_location(volume->resource.locations));
 
-    if ((volume->locations & location) == location)
+    if ((volume->resource.locations & location) == location)
     {
         TRACE("Location(s) already up to date.\n");
         return;
@@ -241,36 +241,36 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
                     && !(volume->container->flags & WINED3D_TEXTURE_SRGB_ALLOCATED)))
                 ERR("Trying to load (s)RGB texture without prior allocation.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & WINED3D_LOCATION_DISCARDED)
             {
                 TRACE("Volume previously discarded, nothing to do.\n");
                 wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
             }
-            else if (volume->locations & WINED3D_LOCATION_SYSMEM)
+            else if (volume->resource.locations & WINED3D_LOCATION_SYSMEM)
             {
                 struct wined3d_const_bo_address data = {0, volume->resource.heap_memory};
                 wined3d_texture_bind_and_dirtify(volume->container, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_volume_upload_data(volume, context, &data);
             }
-            else if (volume->locations & WINED3D_LOCATION_BUFFER)
+            else if (volume->resource.locations & WINED3D_LOCATION_BUFFER)
             {
                 struct wined3d_const_bo_address data = {volume->pbo, NULL};
                 wined3d_texture_bind_and_dirtify(volume->container, context,
                         location == WINED3D_LOCATION_TEXTURE_SRGB);
                 wined3d_volume_upload_data(volume, context, &data);
             }
-            else if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
             {
                 wined3d_volume_srgb_transfer(volume, context, TRUE);
             }
-            else if (volume->locations & WINED3D_LOCATION_TEXTURE_SRGB)
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_SRGB)
             {
                 wined3d_volume_srgb_transfer(volume, context, FALSE);
             }
             else
             {
-                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->locations));
+                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->resource.locations));
                 return;
             }
             wined3d_volume_validate_location(volume, location);
@@ -284,16 +284,16 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             if (!volume->resource.heap_memory)
                 ERR("Trying to load WINED3D_LOCATION_SYSMEM without setting it up first.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & WINED3D_LOCATION_DISCARDED)
             {
                 TRACE("Volume previously discarded, nothing to do.\n");
                 wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
             }
-            else if (volume->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+            else if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
                 struct wined3d_bo_address data = {0, volume->resource.heap_memory};
 
-                if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(volume->container, context, FALSE);
                 else
                     wined3d_texture_bind_and_dirtify(volume->container, context, TRUE);
@@ -304,7 +304,7 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             else
             {
                 FIXME("Implement WINED3D_LOCATION_SYSMEM loading from %s.\n",
-                        wined3d_debug_location(volume->locations));
+                        wined3d_debug_location(volume->resource.locations));
                 return;
             }
             wined3d_volume_validate_location(volume, WINED3D_LOCATION_SYSMEM);
@@ -314,16 +314,16 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             if (!volume->pbo)
                 ERR("Trying to load WINED3D_LOCATION_BUFFER without setting it up first.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & WINED3D_LOCATION_DISCARDED)
             {
                 TRACE("Volume previously discarded, nothing to do.\n");
                 wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
             }
-            else if (volume->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+            else if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
                 struct wined3d_bo_address data = {volume->pbo, NULL};
 
-                if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(volume->container, context, FALSE);
                 else
                     wined3d_texture_bind_and_dirtify(volume->container, context, TRUE);
@@ -333,7 +333,7 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             else
             {
                 FIXME("Implement WINED3D_LOCATION_BUFFER loading from %s.\n",
-                        wined3d_debug_location(volume->locations));
+                        wined3d_debug_location(volume->resource.locations));
                 return;
             }
             wined3d_volume_validate_location(volume, WINED3D_LOCATION_BUFFER);
@@ -341,7 +341,7 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
 
         default:
             FIXME("Implement %s loading from %s.\n", wined3d_debug_location(location),
-                    wined3d_debug_location(volume->locations));
+                    wined3d_debug_location(volume->resource.locations));
     }
 }
 
@@ -565,7 +565,7 @@ HRESULT wined3d_volume_map(struct wined3d_volume *volume,
         {
             wined3d_volume_validate_location(volume, WINED3D_LOCATION_SYSMEM);
         }
-        else if (!(volume->locations & WINED3D_LOCATION_SYSMEM))
+        else if (!(volume->resource.locations & WINED3D_LOCATION_SYSMEM))
         {
             context = context_acquire(device, NULL);
             wined3d_volume_load_location(volume, context, WINED3D_LOCATION_SYSMEM);
@@ -724,7 +724,7 @@ static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture
     }
 
     volume->texture_level = level;
-    volume->locations = WINED3D_LOCATION_DISCARDED;
+    volume->resource.locations = WINED3D_LOCATION_DISCARDED;
 
     if (desc->pool == WINED3D_POOL_DEFAULT && desc->usage & WINED3DUSAGE_DYNAMIC
             && gl_info->supported[ARB_PIXEL_BUFFER_OBJECT]
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index f4b06a4..b25ce65 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -5,7 +5,7 @@
  * Copyright 2002-2003 Raphael Junqueira
  * Copyright 2002-2003, 2004 Jason Edmeades
  * Copyright 2005 Oliver Stieber
- * Copyright 2006-2011, 2013 Stefan Dösinger for CodeWeavers
+ * Copyright 2006-2011, 2013-2014 Stefan Dösinger for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -2197,6 +2197,7 @@ struct wined3d_resource
     void *heap_memory;
     UINT custom_row_pitch, custom_slice_pitch;
     struct list resource_list_entry;
+    DWORD locations;
 
     void *parent;
     const struct wined3d_parent_ops *parent_ops;
@@ -2345,7 +2346,6 @@ struct wined3d_volume
     struct wined3d_resource resource;
     struct wined3d_texture *container;
 
-    DWORD locations;
     GLint texture_level;
     DWORD download_count;
     GLuint pbo;
-- 
2.6.4

