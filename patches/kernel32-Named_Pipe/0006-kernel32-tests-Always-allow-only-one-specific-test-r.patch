From 2ae3b0fe9a03067879de3c7409e212510e134900 Mon Sep 17 00:00:00 2001
From: Sebastian Lackner <sebastian@fds-team.de>
Date: Wed, 30 Jul 2014 18:00:19 +0200
Subject: kernel32/tests: Always allow only one specific test result, add
 todo_wine where necessary.

The current pipe tests are not really a good base for fixing the implemenation -
some of the todo_wine's depend on the return value itself. This hides if one of
the following patches breaks things. Besides that some of the tests are currently
broken on kernel >= 3.12 (bug #35781), mark those as todo_wine.

Changes in v2:
  * Ensure that the APC is properly removed - as it turned out this broke like 20 patches
    later one of the other new tests... ^^
---
 dlls/kernel32/tests/pipe.c |   57 +++++++++++++++++---------------------------
 1 file changed, 22 insertions(+), 35 deletions(-)

diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index f7c7531..5790be8 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -153,20 +153,13 @@ static void test_CreateNamedPipe(int pipemode)
         ok(written == sizeof(obuf2), "write file len 3b\n");
         ok(PeekNamedPipe(hFile, ibuf, sizeof(ibuf), &readden, &avail, NULL), "Peek3\n");
         if (pipemode == PIPE_TYPE_BYTE) {
-            if (readden != sizeof(obuf))  /* Linux only returns the first message */
-                ok(readden == sizeof(obuf) + sizeof(obuf2), "peek3 got %d bytes\n", readden);
-            else
-                todo_wine ok(readden == sizeof(obuf) + sizeof(obuf2), "peek3 got %d bytes\n", readden);
+            todo_wine ok(readden == sizeof(obuf) + sizeof(obuf2), "peek3 got %d bytes\n", readden);
         }
         else
         {
-            if (readden != sizeof(obuf) + sizeof(obuf2))  /* MacOS returns both messages */
-                ok(readden == sizeof(obuf), "peek3 got %d bytes\n", readden);
-            else
-                todo_wine ok(readden == sizeof(obuf), "peek3 got %d bytes\n", readden);
+            ok(readden == sizeof(obuf), "peek3 got %d bytes\n", readden);
         }
-        if (avail != sizeof(obuf)) /* older Linux kernels only return the first write here */
-            ok(avail == sizeof(obuf) + sizeof(obuf2), "peek3 got %d bytes available\n", avail);
+        ok(avail == sizeof(obuf) + sizeof(obuf2), "peek3 got %d bytes available\n", avail);
         pbuf = ibuf;
         ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "pipe content 3a check\n");
         if (pipemode == PIPE_TYPE_BYTE && readden >= sizeof(obuf)+sizeof(obuf2)) {
@@ -188,21 +181,13 @@ static void test_CreateNamedPipe(int pipemode)
         ok(written == sizeof(obuf2), "write file len 4b\n");
         ok(PeekNamedPipe(hnp, ibuf, sizeof(ibuf), &readden, &avail, NULL), "Peek4\n");
         if (pipemode == PIPE_TYPE_BYTE) {
-            if (readden != sizeof(obuf))  /* Linux only returns the first message */
-                /* should return all 23 bytes */
-                ok(readden == sizeof(obuf) + sizeof(obuf2), "peek4 got %d bytes\n", readden);
-            else
-                todo_wine ok(readden == sizeof(obuf) + sizeof(obuf2), "peek4 got %d bytes\n", readden);
+            todo_wine ok(readden == sizeof(obuf) + sizeof(obuf2), "peek4 got %d bytes\n", readden);
         }
         else
         {
-            if (readden != sizeof(obuf) + sizeof(obuf2))  /* MacOS returns both messages */
-                ok(readden == sizeof(obuf), "peek4 got %d bytes\n", readden);
-            else
-                todo_wine ok(readden == sizeof(obuf), "peek4 got %d bytes\n", readden);
+            ok(readden == sizeof(obuf), "peek4 got %d bytes\n", readden);
         }
-        if (avail != sizeof(obuf)) /* older Linux kernels only return the first write here */
-            ok(avail == sizeof(obuf) + sizeof(obuf2), "peek4 got %d bytes available\n", avail);
+        ok(avail == sizeof(obuf) + sizeof(obuf2), "peek4 got %d bytes available\n", avail);
         pbuf = ibuf;
         ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "pipe content 4a check\n");
         if (pipemode == PIPE_TYPE_BYTE && readden >= sizeof(obuf)+sizeof(obuf2)) {
@@ -243,14 +228,8 @@ static void test_CreateNamedPipe(int pipemode)
             ok(WriteFile(hnp, obuf2, sizeof(obuf2), &written, NULL), " WriteFile5b\n");
             ok(written == sizeof(obuf2), "write file len 3b\n");
             ok(PeekNamedPipe(hFile, ibuf, sizeof(ibuf), &readden, &avail, NULL), "Peek5\n");
-            if (readden != sizeof(obuf) + sizeof(obuf2))  /* MacOS returns both writes */
-                ok(readden == sizeof(obuf), "peek5 got %d bytes\n", readden);
-            else
-                todo_wine ok(readden == sizeof(obuf), "peek5 got %d bytes\n", readden);
-            if (avail != sizeof(obuf)) /* older Linux kernels only return the first write here */
-                ok(avail == sizeof(obuf) + sizeof(obuf2), "peek5 got %d bytes available\n", avail);
-            else
-                todo_wine ok(avail == sizeof(obuf) + sizeof(obuf2), "peek5 got %d bytes available\n", avail);
+            ok(readden == sizeof(obuf), "peek5 got %d bytes\n", readden);
+            ok(avail == sizeof(obuf) + sizeof(obuf2), "peek5 got %d bytes available\n", avail);
             pbuf = ibuf;
             ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 5a check\n");
             ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
@@ -279,12 +258,8 @@ static void test_CreateNamedPipe(int pipemode)
             ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), " WriteFile6b\n");
             ok(written == sizeof(obuf2), "write file len 6b\n");
             ok(PeekNamedPipe(hnp, ibuf, sizeof(ibuf), &readden, &avail, NULL), "Peek6\n");
-            if (readden != sizeof(obuf) + sizeof(obuf2))  /* MacOS returns both writes */
-                ok(readden == sizeof(obuf), "peek6 got %d bytes\n", readden);
-            else
-                todo_wine ok(readden == sizeof(obuf), "peek6 got %d bytes\n", readden);
-            if (avail != sizeof(obuf)) /* older Linux kernels only return the first write here */
-                ok(avail == sizeof(obuf) + sizeof(obuf2), "peek6b got %d bytes available\n", avail);
+            ok(readden == sizeof(obuf), "peek6 got %d bytes\n", readden);
+            ok(avail == sizeof(obuf) + sizeof(obuf2), "peek6b got %d bytes available\n", avail);
             pbuf = ibuf;
             ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 6a check\n");
             ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
@@ -1856,7 +1831,19 @@ static void test_readfileex_pending(void)
     ok(completion_called == 0, "completion routine called during ReadFile\n");
 
     wait = WaitForSingleObjectEx(event, 0, TRUE);
+    todo_wine
     ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", wait);
+    if (wait == WAIT_TIMEOUT)
+    {
+        /* work around kernel regression, and read some more */
+        ret = ReadFile(client, read_buf, sizeof(read_buf), &num_bytes, NULL);
+        ok(ret == TRUE, "ReadFile failed\n");
+
+        ok(completion_called == 0, "completion routine called during ReadFile\n");
+
+        wait = WaitForSingleObjectEx(event, 0, TRUE);
+        ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", wait);
+    }
 
     ok(completion_called == 1, "completion routine not called\n");
     ok(completion_errorcode == 0, "completion called with error %x\n", completion_errorcode);
-- 
1.7.9.5

