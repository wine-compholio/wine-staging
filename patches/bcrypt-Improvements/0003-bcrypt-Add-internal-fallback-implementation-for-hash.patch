From 3439b4e5a1fd05c4fb68491c3814de2581e8a5aa Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Tue, 20 Dec 2016 02:36:57 +0100
Subject: bcrypt: Add internal fallback implementation for hash calculations.

---
 dlls/bcrypt/Makefile.in       |   5 +-
 dlls/bcrypt/bcrypt_internal.h |  79 +++++++++++++++++
 dlls/bcrypt/bcrypt_main.c     | 101 ++++++++++++++++++++--
 dlls/bcrypt/sha256.c          | 169 +++++++++++++++++++++++++++++++++++++
 dlls/bcrypt/sha384.c          |  41 +++++++++
 dlls/bcrypt/sha512.c          | 191 ++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 578 insertions(+), 8 deletions(-)
 create mode 100644 dlls/bcrypt/bcrypt_internal.h
 create mode 100644 dlls/bcrypt/sha256.c
 create mode 100644 dlls/bcrypt/sha384.c
 create mode 100644 dlls/bcrypt/sha512.c

diff --git a/dlls/bcrypt/Makefile.in b/dlls/bcrypt/Makefile.in
index ef9d7ead6bc..f54fc5cd482 100644
--- a/dlls/bcrypt/Makefile.in
+++ b/dlls/bcrypt/Makefile.in
@@ -4,6 +4,9 @@ IMPORTLIB = bcrypt
 EXTRAINCL = $(GNUTLS_CFLAGS)
 
 C_SRCS = \
-	bcrypt_main.c
+	bcrypt_main.c \
+	sha256.c \
+	sha384.c \
+	sha512.c
 
 RC_SRCS = version.rc
diff --git a/dlls/bcrypt/bcrypt_internal.h b/dlls/bcrypt/bcrypt_internal.h
new file mode 100644
index 00000000000..8a8f6d170c4
--- /dev/null
+++ b/dlls/bcrypt/bcrypt_internal.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2016 Michael M端ller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#ifndef __BCRYPT_INTERNAL_H
+#define __BCRYPT_INTERNAL_H
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+
+typedef struct
+{
+    ULONG64 len;
+    DWORD h[8];
+    UCHAR buf[64];
+} SHA256_CTX;
+
+void sha256_init(SHA256_CTX *ctx);
+void sha256_update(SHA256_CTX *ctx, const UCHAR *buffer, ULONG len);
+void sha256_finalize(SHA256_CTX *ctx, UCHAR *buffer);
+
+typedef struct
+{
+  ULONG64 len;
+  ULONG64 h[8];
+  UCHAR buf[128];
+} SHA512_CTX;
+
+void sha512_init(SHA512_CTX *ctx);
+void sha512_update(SHA512_CTX *ctx, const UCHAR *buffer, ULONG len);
+void sha512_finalize(SHA512_CTX *ctx, UCHAR *buffer);
+
+void sha384_init(SHA512_CTX *ctx);
+#define sha384_update sha512_update
+void sha384_finalize(SHA512_CTX *ctx, UCHAR *buffer);
+
+/* Definitions from advapi32 */
+typedef struct
+{
+    unsigned int i[2];
+    unsigned int buf[4];
+    unsigned char in[64];
+    unsigned char digest[16];
+} MD5_CTX;
+
+VOID WINAPI MD5Init(MD5_CTX *ctx);
+VOID WINAPI MD5Update(MD5_CTX *ctx, const unsigned char *buf, unsigned int len);
+VOID WINAPI MD5Final(MD5_CTX *ctx);
+
+typedef struct
+{
+   ULONG Unknown[6];
+   ULONG State[5];
+   ULONG Count[2];
+   UCHAR Buffer[64];
+} SHA_CTX;
+
+VOID WINAPI A_SHAInit(SHA_CTX *ctx);
+VOID WINAPI A_SHAUpdate(SHA_CTX *ctx, const UCHAR *buffer, UINT size);
+VOID WINAPI A_SHAFinal(SHA_CTX *ctx, PULONG result);
+
+#endif /* __BCRYPT_INTERNAL_H */
diff --git a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
index 1f22063dbda..fbaece21f47 100644
--- a/dlls/bcrypt/bcrypt_main.c
+++ b/dlls/bcrypt/bcrypt_main.c
@@ -36,6 +36,8 @@
 #include "ntsecapi.h"
 #include "bcrypt.h"
 
+#include "bcrypt_internal.h"
+
 #include "wine/debug.h"
 #include "wine/library.h"
 #include "wine/unicode.h"
@@ -463,27 +465,112 @@ static NTSTATUS hash_finish( struct hash_impl *hash, enum alg_id alg_id,
 #else
 struct hash_impl
 {
-
+    union
+    {
+        MD5_CTX md5;
+        SHA_CTX sha1;
+        SHA256_CTX sha256;
+        SHA512_CTX sha512;
+    } u;
 };
 
 static NTSTATUS hash_init( struct hash_impl *hash, enum alg_id alg_id )
 {
-    ERR( "support for hashes not available at build time\n" );
-    return STATUS_NOT_IMPLEMENTED;
+    switch (alg_id)
+    {
+    case ALG_ID_MD5:
+        MD5Init(&hash->u.md5);
+        break;
+
+    case ALG_ID_SHA1:
+        A_SHAInit(&hash->u.sha1);
+        break;
+
+    case ALG_ID_SHA256:
+        sha256_init(&hash->u.sha256);
+        break;
+
+    case ALG_ID_SHA384:
+        sha384_init(&hash->u.sha512);
+        break;
+
+    case ALG_ID_SHA512:
+        sha512_init(&hash->u.sha512);
+        break;
+
+    default:
+        ERR( "unhandled id %u\n", alg_id );
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    return STATUS_SUCCESS;
 }
 
 static NTSTATUS hash_update( struct hash_impl *hash, enum alg_id alg_id,
                              UCHAR *input, ULONG size )
 {
-    ERR( "support for hashes not available at build time\n" );
-    return STATUS_NOT_IMPLEMENTED;
+    switch (alg_id)
+    {
+    case ALG_ID_MD5:
+        MD5Update(&hash->u.md5, input, size);
+        break;
+
+    case ALG_ID_SHA1:
+        A_SHAUpdate(&hash->u.sha1, input, size);
+        break;
+
+    case ALG_ID_SHA256:
+        sha256_update(&hash->u.sha256, input, size);
+        break;
+
+    case ALG_ID_SHA384:
+        sha384_update(&hash->u.sha512, input, size);
+        break;
+
+    case ALG_ID_SHA512:
+        sha512_update(&hash->u.sha512, input, size);
+        break;
+
+    default:
+        ERR( "unhandled id %u\n", alg_id );
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    return STATUS_SUCCESS;
 }
 
 static NTSTATUS hash_finish( struct hash_impl *hash, enum alg_id alg_id,
                              UCHAR *output, ULONG size )
 {
-    ERR( "support for hashes not available at build time\n" );
-    return STATUS_NOT_IMPLEMENTED;
+    switch (alg_id)
+    {
+    case ALG_ID_MD5:
+        MD5Final(&hash->u.md5);
+        memcpy(output, hash->u.md5.digest, 16);
+        break;
+
+    case ALG_ID_SHA1:
+        A_SHAFinal(&hash->u.sha1, (ULONG*)output);
+        break;
+
+    case ALG_ID_SHA256:
+        sha256_finalize(&hash->u.sha256, output);
+        break;
+
+    case ALG_ID_SHA384:
+        sha384_finalize(&hash->u.sha512, output);
+        break;
+
+    case ALG_ID_SHA512:
+        sha512_finalize(&hash->u.sha512, output);
+        break;
+
+    default:
+        ERR( "unhandled id %u\n", alg_id );
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    return STATUS_SUCCESS;
 }
 #endif
 
diff --git a/dlls/bcrypt/sha256.c b/dlls/bcrypt/sha256.c
new file mode 100644
index 00000000000..48c4a48d031
--- /dev/null
+++ b/dlls/bcrypt/sha256.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright 2016 Michael M端ller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+/* Based on public domain implementation from
+   https://git.musl-libc.org/cgit/musl/tree/src/crypt/crypt_sha256.c */
+
+#include "bcrypt_internal.h"
+
+static DWORD ror(DWORD n, int k) { return (n >> k) | (n << (32-k)); }
+#define Ch(x,y,z)  (z ^ (x & (y ^ z)))
+#define Maj(x,y,z) ((x & y) | (z & (x | y)))
+#define S0(x)      (ror(x,2) ^ ror(x,13) ^ ror(x,22))
+#define S1(x)      (ror(x,6) ^ ror(x,11) ^ ror(x,25))
+#define R0(x)      (ror(x,7) ^ ror(x,18) ^ (x>>3))
+#define R1(x)      (ror(x,17) ^ ror(x,19) ^ (x>>10))
+
+static const DWORD K[64] =
+{
+  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+static void processblock(SHA256_CTX *ctx, const UCHAR *buffer)
+{
+    DWORD W[64], t1, t2, a, b, c, d, e, f, g, h;
+    int i;
+
+    for (i = 0; i < 16; i++)
+    {
+        W[i]  = (DWORD)buffer[4*i]<<24;
+        W[i] |= (DWORD)buffer[4*i+1]<<16;
+        W[i] |= (DWORD)buffer[4*i+2]<<8;
+        W[i] |= buffer[4*i+3];
+    }
+
+    for (; i < 64; i++)
+        W[i] = R1(W[i-2]) + W[i-7] + R0(W[i-15]) + W[i-16];
+
+    a = ctx->h[0];
+    b = ctx->h[1];
+    c = ctx->h[2];
+    d = ctx->h[3];
+    e = ctx->h[4];
+    f = ctx->h[5];
+    g = ctx->h[6];
+    h = ctx->h[7];
+
+    for (i = 0; i < 64; i++)
+    {
+        t1 = h + S1(e) + Ch(e,f,g) + K[i] + W[i];
+        t2 = S0(a) + Maj(a,b,c);
+        h = g;
+        g = f;
+        f = e;
+        e = d + t1;
+        d = c;
+        c = b;
+        b = a;
+        a = t1 + t2;
+    }
+
+    ctx->h[0] += a;
+    ctx->h[1] += b;
+    ctx->h[2] += c;
+    ctx->h[3] += d;
+    ctx->h[4] += e;
+    ctx->h[5] += f;
+    ctx->h[6] += g;
+    ctx->h[7] += h;
+}
+
+static void pad(SHA256_CTX *ctx)
+{
+    ULONG64 r = ctx->len % 64;
+
+    ctx->buf[r++] = 0x80;
+
+    if (r > 56)
+    {
+        memset(ctx->buf + r, 0, 64 - r);
+        r = 0;
+        processblock(ctx, ctx->buf);
+    }
+
+    memset(ctx->buf + r, 0, 56 - r);
+    ctx->len *= 8;
+    ctx->buf[56] = ctx->len >> 56;
+    ctx->buf[57] = ctx->len >> 48;
+    ctx->buf[58] = ctx->len >> 40;
+    ctx->buf[59] = ctx->len >> 32;
+    ctx->buf[60] = ctx->len >> 24;
+    ctx->buf[61] = ctx->len >> 16;
+    ctx->buf[62] = ctx->len >> 8;
+    ctx->buf[63] = ctx->len;
+
+    processblock(ctx, ctx->buf);
+}
+
+void sha256_init(SHA256_CTX *ctx)
+{
+    ctx->len = 0;
+    ctx->h[0] = 0x6a09e667;
+    ctx->h[1] = 0xbb67ae85;
+    ctx->h[2] = 0x3c6ef372;
+    ctx->h[3] = 0xa54ff53a;
+    ctx->h[4] = 0x510e527f;
+    ctx->h[5] = 0x9b05688c;
+    ctx->h[6] = 0x1f83d9ab;
+    ctx->h[7] = 0x5be0cd19;
+}
+
+void sha256_update(SHA256_CTX *ctx, const UCHAR *buffer, ULONG len)
+{
+    const UCHAR *p = buffer;
+    ULONG64 r = ctx->len % 64;
+
+    ctx->len += len;
+    if (r)
+    {
+        if (len < 64 - r)
+        {
+            memcpy(ctx->buf + r, p, len);
+            return;
+        }
+        memcpy(ctx->buf + r, p, 64 - r);
+        len -= 64 - r;
+        p += 64 - r;
+        processblock(ctx, ctx->buf);
+    }
+    for (; len >= 64; len -= 64, p += 64)
+        processblock(ctx, p);
+    memcpy(ctx->buf, p, len);
+}
+
+void sha256_finalize(SHA256_CTX *ctx, UCHAR *buffer)
+{
+    int i;
+
+    pad(ctx);
+    for (i = 0; i < 8; i++)
+    {
+        buffer[4*i]   = ctx->h[i] >> 24;
+        buffer[4*i+1] = ctx->h[i] >> 16;
+        buffer[4*i+2] = ctx->h[i] >> 8;
+        buffer[4*i+3] = ctx->h[i];
+    }
+}
diff --git a/dlls/bcrypt/sha384.c b/dlls/bcrypt/sha384.c
new file mode 100644
index 00000000000..81e7e08fd07
--- /dev/null
+++ b/dlls/bcrypt/sha384.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2016 Michael M端ller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+#include "bcrypt_internal.h"
+
+void sha384_init(SHA512_CTX *ctx)
+{
+    ctx->len = 0;
+    ctx->h[0] = 0xcbbb9d5dc1059ed8ULL;
+    ctx->h[1] = 0x629a292a367cd507ULL;
+    ctx->h[2] = 0x9159015a3070dd17ULL;
+    ctx->h[3] = 0x152fecd8f70e5939ULL;
+    ctx->h[4] = 0x67332667ffc00b31ULL;
+    ctx->h[5] = 0x8eb44a8768581511ULL;
+    ctx->h[6] = 0xdb0c2e0d64f98fa7ULL;
+    ctx->h[7] = 0x47b5481dbefa4fa4ULL;
+}
+
+void sha384_finalize(SHA512_CTX *ctx, UCHAR *buffer)
+{
+    UCHAR buffer512[64];
+
+    sha512_finalize(ctx, buffer512);
+    memcpy(buffer, buffer512, 48);
+}
diff --git a/dlls/bcrypt/sha512.c b/dlls/bcrypt/sha512.c
new file mode 100644
index 00000000000..fdd7867eab7
--- /dev/null
+++ b/dlls/bcrypt/sha512.c
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2016 Michael M端ller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ */
+
+/* Based on public domain implementation from
+   https://git.musl-libc.org/cgit/musl/tree/src/crypt/crypt_sha512.c */
+
+#include "bcrypt_internal.h"
+
+static ULONG64 ror(ULONG64 n, int k) { return (n >> k) | (n << (64-k)); }
+#define Ch(x,y,z)  (z ^ (x & (y ^ z)))
+#define Maj(x,y,z) ((x & y) | (z & (x | y)))
+#define S0(x)      (ror(x,28) ^ ror(x,34) ^ ror(x,39))
+#define S1(x)      (ror(x,14) ^ ror(x,18) ^ ror(x,41))
+#define R0(x)      (ror(x,1) ^ ror(x,8) ^ (x>>7))
+#define R1(x)      (ror(x,19) ^ ror(x,61) ^ (x>>6))
+
+static const ULONG64 K[80] =
+{
+    0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL, 0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
+    0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL, 0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
+    0xd807aa98a3030242ULL, 0x12835b0145706fbeULL, 0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
+    0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL, 0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
+    0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL, 0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
+    0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL, 0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
+    0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL, 0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
+    0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL, 0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
+    0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL, 0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
+    0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL, 0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
+    0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL, 0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
+    0xd192e819d6ef5218ULL, 0xd69906245565a910ULL, 0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
+    0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL, 0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
+    0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL, 0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
+    0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL, 0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
+    0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL, 0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
+    0xca273eceea26619cULL, 0xd186b8c721c0c207ULL, 0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
+    0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL, 0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
+    0x28db77f523047d84ULL, 0x32caab7b40c72493ULL, 0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
+    0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL, 0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
+};
+
+static void processblock(SHA512_CTX *ctx, const UCHAR *buffer)
+{
+    ULONG64 W[80], t1, t2, a, b, c, d, e, f, g, h;
+    int i;
+
+    for (i = 0; i < 16; i++)
+    {
+        W[i]  = (ULONG64)buffer[8*i]<<56;
+        W[i] |= (ULONG64)buffer[8*i+1]<<48;
+        W[i] |= (ULONG64)buffer[8*i+2]<<40;
+        W[i] |= (ULONG64)buffer[8*i+3]<<32;
+        W[i] |= (ULONG64)buffer[8*i+4]<<24;
+        W[i] |= (ULONG64)buffer[8*i+5]<<16;
+        W[i] |= (ULONG64)buffer[8*i+6]<<8;
+        W[i] |= buffer[8*i+7];
+    }
+
+    for (; i < 80; i++)
+        W[i] = R1(W[i-2]) + W[i-7] + R0(W[i-15]) + W[i-16];
+
+    a = ctx->h[0];
+    b = ctx->h[1];
+    c = ctx->h[2];
+    d = ctx->h[3];
+    e = ctx->h[4];
+    f = ctx->h[5];
+    g = ctx->h[6];
+    h = ctx->h[7];
+
+    for (i = 0; i < 80; i++)
+    {
+        t1 = h + S1(e) + Ch(e,f,g) + K[i] + W[i];
+        t2 = S0(a) + Maj(a,b,c);
+        h = g;
+        g = f;
+        f = e;
+        e = d + t1;
+        d = c;
+        c = b;
+        b = a;
+        a = t1 + t2;
+    }
+
+    ctx->h[0] += a;
+    ctx->h[1] += b;
+    ctx->h[2] += c;
+    ctx->h[3] += d;
+    ctx->h[4] += e;
+    ctx->h[5] += f;
+    ctx->h[6] += g;
+    ctx->h[7] += h;
+}
+
+static void pad(SHA512_CTX *ctx)
+{
+    ULONG64 r = ctx->len % 128;
+
+    ctx->buf[r++] = 0x80;
+    if (r > 112)
+    {
+        memset(ctx->buf + r, 0, 128 - r);
+        r = 0;
+        processblock(ctx, ctx->buf);
+    }
+
+    memset(ctx->buf + r, 0, 120 - r);
+    ctx->len *= 8;
+    ctx->buf[120] = ctx->len >> 56;
+    ctx->buf[121] = ctx->len >> 48;
+    ctx->buf[122] = ctx->len >> 40;
+    ctx->buf[123] = ctx->len >> 32;
+    ctx->buf[124] = ctx->len >> 24;
+    ctx->buf[125] = ctx->len >> 16;
+    ctx->buf[126] = ctx->len >> 8;
+    ctx->buf[127] = ctx->len;
+
+    processblock(ctx, ctx->buf);
+}
+
+void sha512_init(SHA512_CTX *ctx)
+{
+    ctx->len = 0;
+    ctx->h[0] = 0x6a09e667f3bcc908ULL;
+    ctx->h[1] = 0xbb67ae8584caa73bULL;
+    ctx->h[2] = 0x3c6ef372fe94f82bULL;
+    ctx->h[3] = 0xa54ff53a5f1d36f1ULL;
+    ctx->h[4] = 0x510e527fade682d1ULL;
+    ctx->h[5] = 0x9b05688c2b3e6c1fULL;
+    ctx->h[6] = 0x1f83d9abfb41bd6bULL;
+    ctx->h[7] = 0x5be0cd19137e2179ULL;
+}
+
+void sha512_update(SHA512_CTX *ctx, const UCHAR *buffer, ULONG len)
+{
+    const UCHAR *p = buffer;
+    unsigned r = ctx->len % 128;
+
+    ctx->len += len;
+    if (r)
+    {
+        if (len < 128 - r)
+        {
+            memcpy(ctx->buf + r, p, len);
+            return;
+        }
+        memcpy(ctx->buf + r, p, 128 - r);
+        len -= 128 - r;
+        p += 128 - r;
+        processblock(ctx, ctx->buf);
+    }
+
+    for (; len >= 128; len -= 128, p += 128)
+        processblock(ctx, p);
+
+    memcpy(ctx->buf, p, len);
+}
+
+void sha512_finalize(SHA512_CTX *ctx, UCHAR *buffer)
+{
+    int i;
+
+    pad(ctx);
+
+    for (i = 0; i < 8; i++)
+    {
+        buffer[8*i] = ctx->h[i] >> 56;
+        buffer[8*i+1] = ctx->h[i] >> 48;
+        buffer[8*i+2] = ctx->h[i] >> 40;
+        buffer[8*i+3] = ctx->h[i] >> 32;
+        buffer[8*i+4] = ctx->h[i] >> 24;
+        buffer[8*i+5] = ctx->h[i] >> 16;
+        buffer[8*i+6] = ctx->h[i] >> 8;
+        buffer[8*i+7] = ctx->h[i];
+    }
+}
-- 
2.11.0

